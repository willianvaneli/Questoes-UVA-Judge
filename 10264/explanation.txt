Esse problema pede que achemos, num cubo de dimensão N, qual par de vértices vizinhos (ou corners, citando a descrição do problema) tem a maior potência, com dita potência dada pela soma dos pesos dos vértices vizinhos. Como sugerido, resolvemos esse problema por meio de manipulação de bits, pois podemos facilmente encontrar todos os vizinhos de um vértice utilizando essa estratégia.
13
Primeiro, criamos um loop externo para manter o funcionamento do código até que o usuário deixe de digitar o tamanho da dimensão do cubo (linha 11). A partir da dimensão do cubo, temos o número de vértices (linha 12), pois Vértices = 2n. Após isso, recebemos como entrada do usuário o peso de cada vértice (linhas 13-14), colocando-os num array de inteiros. Uma vez que temos essas informações, utilizamos os loops das linhas 18 e 20 para analisar cada vértice e cada um de seus vizinhos, respectivamente. Sabemos que cada vértice tem n vizinhos (condição de parada da linha 20), determinamos a posição de cada um por meio de um bitshift (linha 21), determinamos o peso de cada um (linha 22), e adicionamos esse peso `a soma total (linha 23), gerando a potência do vértice. Cada vez que todos os vizinhos de um vértice têm seus pesos somados, guardamos a potência do vértice num array somas (linha 25), e passamos para o próximo vértice. Com essas informações, utilizamos a mesma ideia das linhas 18 e 20 para percorrer os vértices novamente, com os loops das linhas 29 e 30. Damos início a` variável somamax como 0 (linha 28), que servira´ para comparação com outras potências de pares de vértices. Então, dentro dos loops citados, analisamos cada soma de potências de dado vértice com cada um de seus vizinhos (linha 32), atualizando a variável soma-max com a maior potência a cada iteração dos loops, chegando ao resultado.
